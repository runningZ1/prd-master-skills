# TaskMaster完整工作流 - 6步简化流程

## 适用场景

**适合**：需要生成PRD并自动分解为可执行任务的场景。

**核心优势**：
- ✅ 自动将PRD解析为任务列表
- ✅ 智能任务分解（每个需求自动拆分）
- ✅ 依赖自动识别
- ✅ 用户测试检查点插入（每5个任务）
- ✅ 支持自主执行或移交控制

**前提要求**：必须安装TaskMaster（MCP或CLI）

---

## 6步核心工作流

### Step 1: 检测现有PRD

**目标**：在开始新PRD前，检查是否有现有文档

**检测逻辑**：
```python
1. 检查 .taskmaster/ 目录是否存在
   - 是 → 检查 .taskmaster/docs/*.md
   - 否 → 直接进Step 2（新项目）

2. 如找到PRD文件：
   - 读取创建时间、任务状态
   - 提供选项：
     a) 执行现有任务 → 进Step 6
     b) 更新PRD → 进Step 2
     c) 创建新PRD（替换）→ 进Step 2
     d) 审查PRD → 显示摘要后退出
```

**用户交互示例**：
```
🔍 发现现有PRD: prd.md

📊 项目状态：
  - 任务：12个（7完成，5待处理）
  - 完成度：58%

您想做什么？
1. 继续执行现有任务
2. 更新当前PRD
3. 创建新PRD（覆盖当前）
4. 查看PRD摘要
```

---

### Step 2: 检测TaskMaster（必需）

**目标**：确保TaskMaster可用（MCP或CLI）

**检测优先级**：
```
1. MCP Task-Master-AI（首选）
   - 尝试：mcp__task-master-ai__get_tasks
   - 成功 → TASKMASTER_METHOD="MCP" ✅

2. CLI（备选）
   - 运行：which taskmaster && taskmaster --version
   - 成功 → TASKMASTER_METHOD="CLI" ✅

3. 都失败 → 阻塞并提示安装
```

**如果未找到TaskMaster**：
```
⚠️ 需要TaskMaster

此工作流需要TaskMaster才能自动分解任务。

选项1（推荐）：安装MCP Task-Master-AI
  • 添加到Claude Code MCP配置
  • 提供无缝集成

选项2：安装CLI
  • npm install -g task-master-ai

安装完成后输入'done'继续。
```

---

### Step 3: 收集需求（8个核心问题）

**目标**：获取足够信息生成生产级PRD

**问题清单**（相比通用模式简化）：

1. **问题描述** - 要解决什么用户痛点？
2. **目标用户** - 具体哪些角色使用？
3. **解决方案** - 大概如何实现？
4. **成功指标** - 如何量化成功？
5. **技术约束** - 现有技术栈/架构？
6. **是新项目还是现有系统？** - 决定架构策略
7. **优先级** - 最小可行产品（MVP）的范围
8. **时间期望** - 大致交付时间线

**差异化提问**（相比通用模式）：
- 更关注技术实现可行性
- 询问代码库/架构背景
- 明确MVP与后续版本
- 了解团队技术栈

**智能默认值**：
- 未回答的问题使用行业标准假设
- 明确标注所有假设（用⚠️提示）
- 假设中等复杂度（15-30个任务）

---

### Step 4: 生成生产级PRD（11部分）

**目标**：创建工程团队可立即执行的PRD

**PRD结构**（面向工程师优化）：

1. **执行摘要**
   - 1段话：问题 + 方案 + 预期影响

2. **问题陈述**
   - 当前情况和用户/业务痛点
   - 为什么现在解决（紧迫性）

3. **目标与成功指标（SMART）**
   - 3-5个目标，每个都有：指标、基线、目标、时间框架
   - 例："将用户激活率从45%提升到65%（3个月）"

4. **用户故事（敏捷格式）**
   - As a [用户], I want [功能], so that [价值]
   - **关键**：验收标准具体到可成为任务完成检查
   - 每个故事暗示1-3个实现任务

5. **功能需求**
   - 编号：REQ-001, REQ-002...
   - 优先级：必须有/应该有/可以有
   - 每个需求：简短描述 + 技术规格提示

6. **非功能需求**
   - 性能：具体数字（"< 200ms p95"）
   - 安全：认证、加密、合规
   - 可扩展性：用户负载、数据量
   - 可靠性：正常运行时间、错误率

7. **技术考虑（深度）**
   - 架构图示（ASCII或参考）
   - API规范（包含请求/响应示例）
   - 数据库模式变更（SQL/模式示例）
   - 依赖（内部和外部服务）
   - 测试策略（单元、集成、e2e）

8. **实施路线图（TaskMaster优化）**
   - 阶段分解：Phase 1（基础）、Phase 2（核心）、Phase 3（完善）
   - 任务排序：识别依赖关系
   - 复杂度估算：Small/Medium/Large
   - 每个需求的建议任务分解

9. **范围边界**
   - 明确列出不包括的功能
   - 防止范围蔓延

10. **风险与缓解**
    - 已知风险
    - 缓解策略
    - 应急计划

11. **验证检查点**
    - 里程碑：每个阶段结束后的验证标准
    - 质量关卡：用于判断是否可以进入下一阶段

**文档示例**：见 `templates/comprehensive-prd-template.md`

---

### Step 5: 解析PRD并生成任务

**关键步骤**：调用TaskMaster解析PRD并自动分解

**自动计算任务数**：
```
numTasks = (功能需求数 × 2) + (用户故事数 × 1.5)
最小值：8个任务
最大值：35个任务
示例：5个功能需求 × 2 + 8个用户故事 × 1.5 = 22个任务
```

**MCP方式**：
```javascript
mcp__task-master-ai__parse_prd({
  projectRoot: "${PWD}",
  input: ".taskmaster/docs/prd.md",
  numTasks: 24,  // 自动计算
  research: true // 使用研究提升质量
})

→ 完后立即 –

mcp__task-master-ai__expand_all({
  projectRoot: "${PWD}",
  research: true
})
```

**CLI方式**：
```bash
taskmaster parse-prd --input .taskmaster/docs/prd.md --research --num-tasks auto && \
taskmaster expand-all --research
```

**输出**：
```
✅ 已生成 24个任务（预计 8-12天开发）
✅ 已展开：平均每个任务3个子任务（共72个子任务）
✅ 已识别：12个依赖关系
✅ 已创建：5个用户测试检查点
```

---

### Step 6: 选择执行模式

**目标**：确定如何继续（移交控制或自主执行）

**使用AskUserQuestion提问**：

```
您的PRD和任务已准备好！

📊 概览：
  - 任务：24个（Phase 1: 8, Phase 2: 12, Phase 3: 4）
  - 子任务：68个（自动展开）
  - 检查点：5个（每5个任务1个）

🎯 您希望如何继续？

选项A：移交TaskMaster（推荐）
  • 我会显示命令，您手动控制执行
  • 完全控制：您决定何时开始、暂停、调整
  • 适合：需要随时干预的场景

选项B：自主执行
  • 我会自动执行任务（4种模式可选）
  • 在检查点暂停，等待您验证
  • 适合：信任流程，想要效率
```

#### 选项A：移交TaskMaster

**展示命令**：
```bash
# 查看状态
taskmaster status

# 从下一个任务开始
taskmaster next-task

# 查看某个任务
taskmaster get-task 5

# 更新任务状态
taskmaster set-status 5 in-progress
taskmaster set-status 5 done

# 完整文档
cat .taskmaster/docs/prd.md
cat .taskmaster/tasks/tasks.json
```

**退出技能**
→ 您现在可以直接使用TaskMaster命令

#### 选项B：自主执行（4种模式）

**模式1：顺序到检查点（推荐）**
```
逻辑：
- 按ID顺序执行任务
- 每5个任务后暂停
- 等待用户测试验证
- 用户输入"继续"再继续

适合：平衡质量和速度
控制：在检查点有完全控制
```

**模式2：并行到检查点**
```
逻辑：
- 并行执行最多5个相关任务
- 在检查点暂停

适合：更快的进度
控制：在检查点有完全控制
```

**模式3：完全自主**
```
逻辑：
- 自动执行，不间断
- 直到所有任务完成
- 仅在错误时暂停

适合：最大速度
控制：无（除非出错）
```

**模式4：手动控制**
```
逻辑：
- 执行每个任务前询问
- "准备执行任务X，开始吗？"

适合：完全控制
控制：每一步都需要确认
```

**执行模板示例**：
```
🚀 开始自主执行（模式1：顺序到检查点）

📊 计划：
  - Phase 1任务：1-8号（8个）
  - 检查点：任务5后（USER-TEST-1）
  - Phase 2任务：9-20号（12个）
  - 检查点：任务15后（USER-TEST-2）

从任务1开始执行...
[自动执行中...]

✅ 任务1完成：数据库迁移
✅ 任务2完成：API端点实现
✅ 任务3完成：前端组件
✅ 任务4完成：身份验证逻辑
✅ 任务5完成：登录界面

🛑 检查点USER-TEST-1已到达
💡 请手动验证任务1-5的功能，然后输入"继续"

[等待用户输入]
```

---

## 工作流对比

| 阶段 | 通用模式（5步） | TaskMaster模式（6步） | 差异 |
|------|----------------|---------------------|------|
| 需求收集 | 7个问题，关注业务 | 8个问题，关注技术架构 | TMS更技术化 |
| PRD生成 | 13部分（详细） | 11部分（面向工程） | TMS更具体 |
| 任务分解 | 手动（无） | 自动解析+展开 | **TMS核心优势** |
| 用户测试 | 无 | 每5个任务自动插入 | TMS保障质量 |
| 执行 | 无（仅文档） | 4种自动化模式 | TMS端到端 |
| 时长 | 15-20分钟 | 10分钟+0.5小时（自动） | TMS后续效率高 |

---

## 最佳实践

### PRD质量优化

✅ **做这些**：
- 为每个需求提供验收标准（最少3条）
- 包含API示例请求/响应
- 指定性能目标（具体数字）
- 说明错误处理方案
- 补充分支流程和边界情况

❌ **避免这些**：
- 模糊要求（"系统应该快"）
- 重复功能（检查REQ编号）
- 过故事（epic应该拆分）
- 依赖缺失（会阻塞任务执行）

### 任务质量检查

生成任务后，验证：
- [ ] 每个任务有ID、标题、描述
- [ ] 时间估算合理（Small=2-4h, Medium=4-8h, Large=8-16h）
- [ ] 任务依赖已识别（使用depends_on）
- [ ] 每个P0需求有对应任务
- [ ] 任务能用验收标准验证

---

## 故障排查

### 问题1：生成的任务太模糊

**症状**：
```
Task: "实现用户认证"
Task: "修复Bug"
Task: "测试功能"
```

**原因**：PRD的验收标准太笼统

**解决**：
```diff
- 验收标准：系统能认证用户
+ 验收标准：
+ 1. POST /auth/login返回200且包含JWT
+ 2. 无效密码返回401 Unauthorized
+ 3. 成功后更新last_login时间戳
```

---

### 问题2：任务依赖错误

**症状**：Taskmaster尝试先执行依赖任务B

**原因**：PRD中未明确说明依赖

**解决**：
```markdown
### REQ-003: 用户仪表盘
依赖关系：
- REQ-001（用户认证）- 必须先有用户系统
- REQ-002（用户档案）- 需要用户数据
```

---

### 问题3：任务量过大（>50个）

**症状**：感觉任务太多，开发需要1个月以上

**原因**：需求太宽泛

**解决**：
```markdown
# Before（不好）
REQ-001: 完整的用户认证系统（10个功能）

# After（好）
REQ-001: 用户注册
REQ-002: 用户登录
REQ-003: 密码重置
REQ-004: 电子邮件验证
# 每个需求5-15个任务，总共15-30个任务
```

---

## 快速参考

### MCP命令速查

```javascript
// 检查状态
mcp__task-master-ai__get_tasks({projectRoot})

// 获取特定任务
mcp__task-master-ai__get_task({projectRoot, id: "5"})

// 设置任务状态
mcp__task-master-ai__set_task_status({
  projectRoot,
  id: "5",
  status: "done"  // pending, in-progress, review, done
})

// 更新任务细节
mcp__task-master-ai__update_subtask({
  projectRoot,
  id: "5.2",
  prompt: "添加新进度"
})
```

### CLI命令速查

```bash
# 查看状态
taskmaster status

# 下一个任务
taskmaster next-task

# 查看任务
taskmaster get-task 5

# 设置状态
taskmaster set-status 5 done

# 更新任务
taskmaster update 5 "添加进度描述"
```

---

## 为什么只需要6步？

**对比v3.0的12步工作流**：
- ❌ 删除了 "13项自动化检查"（理论性太强）
- ❌ 删除了 "5个自动化脚本"（维护成本高）
- ❌ 删除了 "选择执行模式"的复杂分支
- ✅ 保留了核心：检测→PRD→任务→执行

**核心价值**：
- 规划时间减少50%（15分钟→8分钟）
- 文档体积减少60%（845行→320行）
- 用户上手时间减少70%（理解成本更低）
- 产出质量保持不变（去掉的都是理论化内容）

---

**时长**：PRD生成（10分钟）+ 任务分解（5分钟）= 15分钟
**质量**：生产级PRD + 可执行任务
**效率**：从想法到可执行任务，30分钟内完成
